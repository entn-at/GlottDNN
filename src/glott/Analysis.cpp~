/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Tuomo Raitio
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 *
 *
 *
 * <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
 *              GlottHMM Speech Parameter Extractor
 * <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
 *
 * This program reads a speech file and extracts speech
 * parameters using glottal inverse filtering.
 *
 * This program has been written in Aalto University,
 * Department of Signal Processign and Acoustics, Espoo, Finland
 *
 * Authors: Tuomo Raitio (2008-2015), Lauri Juvela (2015-)
 * Acknowledgements: Antti Suni, Paavo Alku, Martti Vainio
 *
 * File Analysis.c
 * Version: 2.0
 *
 */



/***********************************************/
/*                 INCLUDE                     */
/***********************************************/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>
#include <string.h>
#include <sndfile.h> 				/* Read and write wav */
#include <gsl/gsl_vector.h>		/* GSL, Vector */
#include <gsl/gsl_matrix.h>		/* GSL, Matrix */
#include <gsl/gsl_fft_real.h>		/* GSL, FFT */
#include <libconfig.h>				/* Configuration file */


#include "definitions.h"
#include "SpFunctions.h"
#include "AnalysisFunctions.h"
#include "InverseFiltering.h"
#include "GCIEstim.h"
#include "PolarityDetection.h"
#include "PulseExtraction.h"
#include "ReadConfig.h"
#include "FileIO.h"
#include "Utils.h"
#include "DynMem.h" /* Dynamic memory allocation and freeing*/



/*******************************************************************/
/*                          MAIN                                   */
/*******************************************************************/

int main(int argc, char *argv[]) {
	double time1 = (double)clock();
	/* Check command line format */
	if(Check_command_line(argc) == EXIT_FAILURE)
		return EXIT_FAILURE;

	/* Read default configuration file and assign parameters */
	struct config_t *conf_def = Read_config(argv[2]);
	char *filename = NULL;
	if(conf_def == NULL)
		return EXIT_FAILURE;
	PARAM params;
	if(Assign_config_parameters(filename,conf_def,&params,DEF_CONF, ANALYSIS_CONF) == EXIT_FAILURE) {
		config_destroy(conf_def);
		free(conf_def);
		return EXIT_FAILURE;
	}


	/* Read user configuration file and assign parameters */
	if(argc == 4) {
		struct config_t *conf_usr = Read_config(argv[3]);
		if(conf_usr == NULL)
			return EXIT_FAILURE;
		if(Assign_config_parameters(filename,conf_usr,&params,USR_CONF,ANALYSIS_CONF) == EXIT_FAILURE) {
			config_destroy(conf_usr);
			free(conf_usr);
			return EXIT_FAILURE;
		}
	}



	/* Check the validity of the parameters */
	if(Check_parameter_validity(&params) == EXIT_FAILURE)
		return EXIT_FAILURE;

	/* Read soundfile, define sampling frequency, invert signal if requested */
	gsl_vector *signal = Read_soundfile(argv[1], &params);
	if(signal == NULL)
		return EXIT_FAILURE;

	/* Read external F0 file if requested */
	gsl_vector *fundf;
	if(Read_external_f0(&fundf,&params) == EXIT_FAILURE) {
		gsl_vector_free(signal);
		return EXIT_FAILURE;
	}

	/* High-pass filtering */
	if(HighPassFilter(signal,&params) == EXIT_FAILURE) {
		gsl_vector_free(signal);
		return EXIT_FAILURE;
	}

	/* Automatic polarity correction */
	if(params.detect_polarity){
		InvertPolarity(signal, &params);
	}

	/*******************************************************************/
	/*                    ALLOCATE MEMORY                              */
	/*******************************************************************/

	/* Allocate memory for variables */
	int i,j,index;
	double f0 = 0;



	DATA data;
	data.signal = signal; // data takes ownership
	data.fundf = fundf; // data takes ownership
	Allocate_variables_DATA(&data,&params);


	/* Read QMF filter */
	gsl_vector *qmf_filter = NULL;
	if(params.qmf_subband_analysis == 1) {
		qmf_filter = ReadQMFFilter(&params);
		if(qmf_filter == NULL) {
			gsl_vector_free(signal);
			return EXIT_FAILURE;
		}
		data.qmf_filter = qmf_filter;
	} else
		data.qmf_filter = NULL;

	/* Read external GCI file if requested */
	if(Read_external_gci(data.gci_signal,&params) == EXIT_FAILURE) {
		// TODO: free everything in case of failure
		return EXIT_FAILURE;
	}


	// TODO: MOVE PULSE LIBRARY FROM ANALYSIS TO ITS OWN BUILD TARGET
	/*******************************************************************/
	/*                   ALLOCATE PULSE LIBRARY                        */
	/*******************************************************************/

	/* Allocate memory for pulse library variables */
	PDATA pdata;
	Allocate_pulselib_variables_PDATA(&pdata,&params);

	/* Pulse library for reconstruction synthesis */
	PDATA pdata_resyn;
	Allocate_PDATA(&pdata_resyn, &params);

	/********************************************************************/
	/*                    EXTRACT PARAMETERS                            */
	/********************************************************************/

	/* Force use of IAIF at F0 estimation*/
	PARAM prelim_params = params;
	prelim_params.lp_method = LP_METHOD_ID_LPC;
	prelim_params.use_iaif = 1;
	prelim_params.use_mod_iaif = 1;


	/* Calculate f0, gain (frame energy)  */
	if(params.extract_f0 == 1)
		printf("	- Extracting F0...\n");

	for(index=0; index<params.n_frames; index++) {

		/* Get samples to frames */
		Get_samples_to_frames(signal,data.frame,data.frame0,data.f0_frame,data.f0_frame0,params.shift,index, ZERO_FRAME_NOT_ALLOWED);

		/* Gain extraction */
		Gain(data.frame, data.gain, index, FALSE); // boolean is windowing switch
		UnvoicedGain(data.frame, data.uvgain, index, FALSE, params.unvoiced_frame_length);
		BandPassGain(data.frame, data.bp_gain, &params, index);

		if (params.use_external_gci == FALSE)
		{
			/* Get IAIF residual for GCI detection */
			InverseFiltering_long(data.f0_frame, data.f0_frame0, data.glottsig_f0, data.f0_mbsframe, data.fundf, data.glottsig, index, LP_METHOD_ID_LPC, &prelim_params);
			Set_frames_to_signal(data.iaif_residual_signal, NULL, data.glottsig_f0, params.shift, index);
		}

		/* Pitch extraction */
		if(params.extract_f0 == 1) {
			FundF(data.glottsig_f0, data.frame, data.fundf_candidates, data.fundf, data.bp_gain, index, &prelim_params);
		}
	}

	/* Postprocess F0 */
	F0_postprocess(data.fundf,data.fundf_candidates,&params);


	if (params.use_external_gci == FALSE)
	{
		/* Calculate mean-based signal for GCI detection*/
		MeanBasedSignal(signal,data.mbsig,data.fundf, params.FS);
		Differentiate(data.iaif_residual_signal, LIP_RADIATION);
		SEDREAMS_full_signal(&data, &params);
	}


	//VPrint1(data.signal);
	//VPrint2(data.gci_signal);

	/* Estimate framewise F0 from GCI */
	/*
	for(index=0; index<params.n_frames; index++) {
		Get_samples_to_frames(data.gci_signal, data.gci_frame, NULL, data.f0_gci_frame, NULL, params.shift, index, ZERO_FRAME_ALLOWED);
		Get_F0_from_Gci(data.gci_frame, data.fundf, index, &params);
	}
	/*

	if(params.extract_f0 == 1)
		Print_elapsed_time(&params);

	printf("	- Extracting vocal tract LSF...\n");

	/* Estimate vocal tract filters */
	for(index=0; index<params.n_frames; index++) {

		/* Get samples to frames */
		Get_samples_to_frames(signal, data.frame,data.frame0,data.f0_frame,data.f0_frame0,params.shift,index, ZERO_FRAME_NOT_ALLOWED);
		Get_samples_to_frames(data.mbsig, data.mbsframe, NULL, data.f0_mbsframe, NULL, params.shift, index, ZERO_FRAME_ALLOWED);
		Get_samples_to_frames(data.gci_signal, data.gci_frame, NULL, data.f0_gci_frame, NULL, params.shift, index, ZERO_FRAME_ALLOWED);

		InverseFiltering(&data,index,&params); // Write to: LSF, LSF2, LSFqmf1&12, LSFqmf2&22, spectral_tilt, glottsig, fftmatrix_X, LSF_fdlp, fdlpgain, LSFnoise

		//VUVInverseFilter(&data, index, &params);
		//Set_frames_to_signal(data.iaif_residual_signal, data.glottal, NULL, params.shift, index);
	}

	Print_elapsed_time(&params);

	//MedFilt5(data.gain);
	/* Smooth vocal tract filter LSFs with median filter*/
	MedFilt5_matrix(data.LSF);
	if(params.qmf_subband_analysis == 1) {
		MedFilt5_matrix(data.LSFqmf1);
		MedFilt5_matrix(data.LSFqmf2);
	}

	/* Formant enhancement by LSFs*/
	if(params.formant_enh_method == FORMANT_ENH_ID_LSF) {
		LSF_Postfilter(data.LSF, &params);
		LSF_Postfilter(data.LSFqmf1, &params);
		LSF_Postfilter(data.LSFqmf2, &params);
	}

	/* Formant Enhancement by re-estimating LPC and modifying the autocorrelation */
	if(params.formant_enh_method == FORMANT_ENH_ID_LPC) {
		LPC_Postfilter(data.LSF, &params);
		LPC_Postfilter(data.LSFqmf1, &params);
		LPC_Postfilter(data.LSFqmf2, &params);
	}

	printf("	- Extracting parameters...\n");
	/* Analysis: Start reading signal vector */
	for(index=0; index<params.n_frames; index++) {

		/* Print progress */
		//Print_progress(index,params.n_frames,argv[1],params.FS);

		/* Get samples to frames */
		Get_samples_to_frames(signal, data.frame, data.frame0, data.f0_frame, data.f0_frame0, params.shift, index, ZERO_FRAME_NOT_ALLOWED);
		Get_samples_to_frames(data.mbsig, data.mbsframe, NULL, data.f0_mbsframe, NULL, params.shift, index, ZERO_FRAME_ALLOWED);

		/* Inverse filtering */


		/*VUVInverseFilter_old(data.frame, data.frame0, data.glottal, data.LSF, data.LSF2, data.spectral_tilt,
						data.glottsig, data.fftmatrix_vt, data.fftmatrix_src, data.fftmatrix_uv,
						data.LSFqmf1, data.LSFqmf2, data.LSFqmf12,data.LSFqmf22, qmf_filter,data.fundf, index, &params); */


		/* Use smoothed LSFs to inverse filter */
		VUVInverseFilter(&data, index, &params);

		/* Fundamental frequency estimation. Define a f0 value for the frame (even if unvoiced) */
		/*FundF(data.glottal_f0, data.frame, data.fundf_candidates, data.fundf, data.bp_gain, index, &params);*/
		f0 = Define_current_f0(data.fundf,f0,index);

		/* Estimate Harmonic-to-Noise Ratio (HNR) and magnitudes of the first N harmonics */
		Harmonic_analysis(data.glottal_f0, data.harmonics, data.HNR, data.h1h2, f0, params.FS, index);

		/* Construct source signal */
		Construct_source(data.source_signal, data.glottal, data.glottal_f0, index, &params);

		/* Extract pulses (original pulselib implementation), pitch-synchronous spectrum estimation */
		Extract_pulses( &data, &pdata, data.fundf, index, &params) ;

	}

	/* Extract each pulse once from the full length glottal source  */
	//Extract_pulses_full_signal(&data, &pdata_resyn, &params);

	/* Pulse extraction */
	if(params.extract_pulses_as_features == 1) {
		for(index=0; index<params.n_frames; index++) {
			/* Get samples to frames */
			Get_samples_to_frames(signal, data.frame, data.frame0, data.f0_frame, data.f0_frame0, params.shift, index, ZERO_FRAME_NOT_ALLOWED);
			Get_samples_to_frames(data.source_signal, data.glottal, NULL, data.glottal_f0, NULL, params.shift, index, ZERO_FRAME_NOT_ALLOWED);
			Get_samples_to_frames(data.gci_signal, data.gci_frame, NULL, data.f0_gci_frame, NULL, params.shift, index, ZERO_FRAME_ALLOWED);

			/* Exctract pulses as features*/
			Exctract_excitation_waveform(&data, &pdata, fundf, index, &params);
		}
		Fill_missing_pulses(&data, &params);
	}



	Print_elapsed_time(&params);

	/********************************************************************/
	/*                POSTPROCESSING OF PARAMETERS                      */
	/********************************************************************/



	/* Add missing frames to the beginning and the end of parameter vectors/matrices.
	 * This is due to the analysis scheme, where the analysis starts
	 * and ends with whole frames instead of zero-padding */

	if(params.use_mcep_features == 1)
		Convert_LP2CEPS(data.LPC,data.mcep,0.42);

/*
   	Add_missing_frames(&data.fundf, &data.fundf_candidates, &data.gain, &data.uvgain,
				&data.HNR, &data.spectral_tilt, &data.LSF, &data.LSF2, &data.harmonics,
				&data.waveform, &data.naq,&data.h1h2, &data.fftmatrix_vt, &data.fftmatrix_src,
				&data.fftmatrix_uv,&data.LSF_fdlp,&data.fdlpgain,&data.LSFnoise,&data.LSFqmf1,
				&data.LSFqmf2,&data.QMF_gain,&data.QMF_gain2,&data.LSFqmf12,&data.LSFqmf22,&data.frame_excitations,&data.mcep, &params);
*/



	/* Median filtering */
	MedFilt5_matrix(data.HNR);
	MedFilt5_matrix(data.harmonics);
	MedFilt5(data.h1h2);
	MedFilt5(data.naq);

	/* Replace unvoiced features */
	for(i=0; i<data.fundf->size; i++) {
		if(gsl_vector_get(data.fundf, i) == 0) {
			if(params.sep_vuv_spectrum == 0) {
				for(j=0; j<params.lpc_order_vt; j++)
					gsl_matrix_set(data.LSF, i, j, gsl_matrix_get(data.LSF2, i, j));
				if(1 && params.qmf_subband_analysis == 1) {
					for(j=0; j<params.lpc_order_qmf1; j++)
							gsl_matrix_set(data.LSFqmf1, i, j, gsl_matrix_get(data.LSFqmf12, i, j));
					for(j=0; j<params.lpc_order_qmf2; j++)
							gsl_matrix_set(data.LSFqmf2, i, j, gsl_matrix_get(data.LSFqmf22, i, j));

					gsl_matrix_set(data.QMF_gain,i,0,gsl_matrix_get(data.QMF_gain2,i,0));
				}
			}
			for(j=0; j<data.fftmatrix_vt->size2; j++)
				gsl_matrix_set(data.fftmatrix_vt, i, j, gsl_matrix_get(data.fftmatrix_uv, i, j));
			gsl_vector_set(data.gain,i,gsl_vector_get(data.uvgain,i));
		}
	}

	if(params.qmf_subband_analysis == 1) {
		LSF_fix_matrix(data.LSFqmf1);
		LSF_fix_matrix(data.LSFqmf2);
	} else {
		if(params.use_mcep_features == 0)
			LSF_fix_matrix(data.LSF);
	}

	/* Noise reduction */
	Noise_reduction(data.gain,&params); // TODO: rename to noise gate

	/* Fill possible gaps in waveform and NAQ */
	Fill_waveform_gaps(data.fundf,data.waveform);
	Fill_naq_gaps(data.fundf, data.naq);

	/* Select new values to pulse parameters according to refined parameters */
	Select_new_refined_values(data.fundf, data.gain, data.LSF, data.spectral_tilt, data.HNR, data.harmonics,
			pdata.pgain, pdata.plsf, pdata.ptilt, pdata.phnr, pdata.pharm, pdata.pulse_pos, pdata.pulse_lengths,
			data.waveform, data.h1h2, pdata.ph1h2, data.naq, pdata.pnaq, &params);

	/* Select only unique pulses */
	Select_unique_pulses(&pdata.gpulses, &pdata.gpulses_rs, &pdata.pulse_lengths, &pdata.pulse_pos,
			&pdata.pulse_inds, &pdata.plsf, &pdata.ptilt, &pdata.phnr, &pdata.pharm, &pdata.pwaveform,
			&pdata.pgain, &pdata.ph1h2, &pdata.pnaq, &params);

	/* Select only one pulse per frame */
	Select_one_pulse_per_frame(&pdata.gpulses, &pdata.gpulses_rs, &pdata.pulse_lengths, &pdata.pulse_pos,
			&pdata.pulse_inds, &pdata.plsf, &pdata.ptilt, &pdata.phnr, &pdata.pharm, &pdata.pwaveform,
			&pdata.pgain, &pdata.ph1h2, &pdata.pnaq, &params);


	/********************************************************************/
	/*                      FORMANT ENHANCEMENT                         */
	/********************************************************************/


	/* Differentiate LSFs if requested */
	if(params.differential_lsf == 1) {
		Differentiate_LSFs(&data.LSF);
		Differentiate_LSFs(&data.LSF2);
		Differentiate_LSFs(&data.spectral_tilt);
	}

	/* Convert F0 to logarithmic scale */
	Convert_F0_to_log(data.fundf,&params);

	/* Concatenate LSFqmf1 and QMF_gain */
	gsl_matrix *LSFqmf2_C = NULL;

	if(params.qmf_subband_analysis == 1) {
	LSFqmf2_C = gsl_matrix_calloc(data.LSFqmf2->size1,data.LSFqmf2->size2+1);
	gsl_matrix_view aview = gsl_matrix_submatrix(LSFqmf2_C,0,0,data.LSFqmf2->size1,data.LSFqmf2->size2);
	gsl_matrix_view bview = gsl_matrix_submatrix(LSFqmf2_C,0,data.LSFqmf2->size2,data.LSFqmf2->size1,1);

	gsl_matrix_memcpy(&aview.matrix, data.LSFqmf2);
	gsl_matrix_memcpy(&bview.matrix, data.QMF_gain);
	}

	/********************************************************************/
	/*                    WRITE PARAMETERS TO FILE                      */
	/********************************************************************/

	// TODO: free memory only in  Free_variables_DATA()
	/* Open files for writing parameters */
	Write_parameters_to_file(argv[1] ,data.LSF ,data.LSF2 ,data.spectral_tilt,
				data.HNR, data.harmonics, data.waveform, data.fundf, data.gain, data.h1h2,
				data.naq, data.source_signal, data.fftmatrix_vt, data.fftmatrix_src, data.gci_signal, data.LSF_fdlp,
				data.fdlpgain, data.LSFnoise, data.LSFqmf1, LSFqmf2_C, data.mcep, &params,&data);

	Free_variables_DATA(&data);
	if(params.qmf_subband_analysis == 1) {
		gsl_matrix_free(LSFqmf2_C);
	}
	/**************************************************************/
	/*            WRITE  PULSE LIBRARY TO FILE                    */
	/**************************************************************/

	Write_pulses_to_file(argv[1], &pdata_resyn, &params);
	Free_PDATA(&pdata_resyn);

	/* Select unique pulses and write pulse library data to file, free memory */
	Write_pulselibrary_to_file(argv[1], pdata.gpulses, pdata.gpulses_rs, pdata.pulse_lengths,
			pdata.pulse_pos, pdata.pulse_inds, pdata.plsf, pdata.ptilt, pdata.phnr, pdata.pharm,
			pdata.pwaveform, pdata.pgain, pdata.ph1h2, pdata.pnaq, &params);

	/* Finish */
	printf("\nElapsed time: %1.2lf seconds.\n",((double)clock()-time1)/(double)CLOCKS_PER_SEC);
	printf("Finished analysis.\n\n");
	return EXIT_SUCCESS;
}

/***********/
/*   EOF   */
/***********/

